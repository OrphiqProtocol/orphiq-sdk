mod method_handler;
mod migration_handler;
mod module;

use proc_macro2::TokenStream;
use quote::quote;

use crate::generators as gen;

/// Given an `impl MyModule` block, produces an `impl *Handler for MyModule`.
/// See `sdk_derive()` in lib.rs for details.
pub fn derive_module(impl_block: syn::ItemImpl) -> TokenStream {
    let sdk_crate = gen::sdk_crate_path();
    let module_generics = &impl_block.generics;
    let module_ty = &impl_block.self_ty;

    let mut base_impls: Vec<TokenStream> = Vec::new();
    let mut derivations: Vec<TokenStream> = Vec::new();

    let mut derivers: Vec<Box<dyn Deriver>> = vec![
        module::DeriveModule::new(),
        migration_handler::DeriveMigrationHandler::new(),
        method_handler::DeriveMethodHandler::new(),
    ];

    // Iterate through all impl items, collecting them and then deriving everything.
    'items: for item in impl_block.items {
        let mut item = Some(item);

        for deriver in derivers.iter_mut() {
            item = deriver.preprocess(item.take().expect("no deriver claimed the item"));
            if item.is_none() {
                continue 'items;
            }
        }

        // No deriver claimed the item.
        let item = item.expect("no deriver claimed the item");
        base_impls.push(quote!(#item));
    }

    // Perform the derivation process.
    for deriver in derivers.iter_mut() {
        let derivation = deriver.derive(module_generics, module_ty);
        derivations.push(derivation);
    }

    let base_impls = if base_impls.is_empty() {
        None
    } else {
        Some(quote! {
            #[automatically_derived]
            impl #module_generics #module_ty {
                #(#base_impls)*
            }
        })
    };

    gen::wrap_in_const(quote! {
        use #sdk_crate::{
          self as sdk,
          cbor,
          error::Error as _,
          module::{DispatchResult, CallResult},
          modules::core::types as core_types,
          types::message::MessageResult
        };

        #(#derivations)*
        #base_impls
    })
}

trait Deriver {
    fn preprocess(&mut self, item: syn::ImplItem) -> Option<syn::ImplItem>;

    #[allow(clippy::borrowed_box)]
    fn derive(&mut self, generics: &syn::Generics, ty: &Box<syn::Type>) -> TokenStream;
}

#[cfg(test)]
mod tests {
    // Helper; asserts that `derive_module` generates the `expected` code from `input`.
    fn expect_module_impl(input: syn::ItemImpl, expected: syn::Stmt) {
        let derivation = super::derive_module(input);
        let actual: syn::Stmt = syn::parse2(derivation).unwrap();

        crate::assert_empty_diff!(actual, expected);
    }

    // The `uses` statement common to all autogenerated impls.
    thread_local! {
      static USES: proc_macro2::TokenStream = quote::quote! {
            use ::oasis_runtime_sdk::{
                  self as sdk, cbor,
                  error::Error as _,
                  module::{CallResult, DispatchResult},
                  modules::core::types as core_types,
                  types::message::MessageResult,
              };
      }
    }

    /// Unannotated functions in the input impl block should be assumed to be a part of the base
    /// type implementation.
    #[test]
    fn generate_method_handler_impl_unannotated_func() {
        let input = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                fn unannotated_fn_should_be_passed_thru(foo: Bar) -> Baz {}
            }
        );

        expect_module_impl(
            input,
            USES.with(|uses| {
                syn::parse_quote!(
                    const _: () = {
                        #uses
                        #[automatically_derived]
                        impl<C: Cfg> sdk::module::MethodHandler for MyModule<C> {
                            fn dispatch_query<C: Context>(
                                ctx: &C,
                                method: &str,
                                args: cbor::Value,
                            ) -> DispatchResult<cbor::Value, Result<cbor::Value, sdk::error::RuntimeError>>
                            {
                                match method {
                                    q if q == format!("{}.Parameters", Self::NAME) => {
                                        module::dispatch_query(ctx, args, Self::query_parameters)
                                    }
                                    _ => DispatchResult::Unhandled(args),
                                }
                            }
                        }
                        #[automatically_derived]
                        impl<C: Cfg> MyModule<C> {
                            fn query_parameters<C: Context>(_ctx: &C, _args: ()) -> Result<<Self as module::Module>::Parameters, <Self as module::Module>::Error> {
                                Ok(Self::params())
                            }
                        }
                        #[automatically_derived]
                        impl<C: Cfg> MyModule<C> {
                            fn unannotated_fn_should_be_passed_thru(foo: Bar) -> Baz {}
                        }
                    };
                )
            }),
        );
    }

    #[test]
    fn generate_method_handler_impl_calls() {
        let input = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(prefetch = "my_module.MyCall")]
                fn prefetch_for_my_call() {}
                #[handler(call = "my_module.MyCall")]
                fn my_call(foo2: Bar2) -> Baz2 {}
                #[handler(call = "my_module.MyOtherCall")]
                fn my_other_call(foo3: Bar3) -> Baz3 {}
                #[handler(call = "my_module.MyInternalCall", internal)]
                fn my_internal_call(foo4: Bar4) -> Baz4 {}
            }
        );

        expect_module_impl(
            input,
            USES.with(|uses| {
                syn::parse_quote!(
                    const _: () = {
                        #uses
                        #[automatically_derived]
                        impl<C: Cfg> sdk::module::MethodHandler for MyModule<C> {
                            fn prefetch(
                                prefixes: &mut BTreeSet<Prefix>,
                                method: &str,
                                body: cbor::Value,
                                auth_info: &AuthInfo,
                            ) -> module::DispatchResult<cbor::Value, Result<(), sdk::error::RuntimeError>> {
                                let mut add_prefix = |p| {
                                    prefixes.insert(p);
                                };
                                match method {
                                    "my_module.MyCall" => module::DispatchResult::Handled(
                                        Self::prefetch_for_my_call(&mut add_prefix, body, auth_info),
                                    ),
                                    "my_module.MyOtherCall" => module::DispatchResult::Handled(Ok(())),
                                    "my_module.MyInternalCall" => module::DispatchResult::Handled(Ok(())),
                                    _ => module::DispatchResult::Unhandled(body),
                                }
                            }
                            fn dispatch_call<C: Context>(
                                ctx: &C,
                                method: &str,
                                body: cbor::Value,
                            ) -> DispatchResult<cbor::Value, CallResult> {
                                match method {
                                    "my_module.MyCall" => module::dispatch_call(ctx, body, Self::my_call),
                                    "my_module.MyOtherCall" => {
                                        module::dispatch_call(ctx, body, Self::my_other_call)
                                    }
                                    "my_module.MyInternalCall" => module::dispatch_call(ctx, body, |ctx, body| {
                                        if !sdk::state::CurrentState::with_env(|env| env.is_internal()) {
                                            return Err(sdk::modules::core::Error::Forbidden.into());
                                        }
                                        Self::my_internal_call(ctx, body)
                                    }),
                                    _ => DispatchResult::Unhandled(body),
                                }
                            }
                            fn dispatch_query<C: Context>(
                                ctx: &C,
                                method: &str,
                                args: cbor::Value,
                            ) -> DispatchResult<cbor::Value, Result<cbor::Value, sdk::error::RuntimeError>>
                            {
                                match method {
                                    q if q == format!("{}.Parameters", Self::NAME) => {
                                        module::dispatch_query(ctx, args, Self::query_parameters)
                                    }
                                    _ => DispatchResult::Unhandled(args),
                                }
                            }
                            fn supported_methods() -> Vec<core_types::MethodHandlerInfo> {
                                vec![
                                    core_types::MethodHandlerInfo {
                                        kind: core_types::MethodHandlerKind::Call,
                                        name: "my_module.MyCall".to_string(),
                                    },
                                    core_types::MethodHandlerInfo {
                                        kind: core_types::MethodHandlerKind::Call,
                                        name: "my_module.MyOtherCall".to_string(),
                                    },
                                    core_types::MethodHandlerInfo {
                                        kind: core_types::MethodHandlerKind::Call,
                                        name: "my_module.MyInternalCall".to_string(),
                                    },
                                ]
                            }
                        }
                        #[automatically_derived]
                        impl<C: Cfg> MyModule<C> {
                            fn query_parameters<C: Context>(_ctx: &C, _args: ()) -> Result<<Self as module::Module>::Parameters, <Self as module::Module>::Error> {
                                Ok(Self::params())
                            }
                            #[handler(prefetch = "my_module.MyCall")]
                            fn prefetch_for_my_call() {}
                            #[handler(call = "my_module.MyCall")]
                            fn my_call(foo2: Bar2) -> Baz2 {}
                            #[handler(call = "my_module.MyOtherCall")]
                            fn my_other_call(foo3: Bar3) -> Baz3 {}
                            #[handler(call = "my_module.MyInternalCall", internal)]
                            fn my_internal_call(foo4: Bar4) -> Baz4 {}
                        }
                    };
                )
            }),
        );
    }

    #[test]
    fn generate_method_handler_impl_queries() {
        let input = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(query = RPC_NAME_OF_MY_QUERY)]
                fn my_query() -> () {}
                #[handler(query = "module.OtherQuery", expensive)]
                fn my_other_query() -> () {}
                #[handler(query = "module.ConfidentialQuery", expensive, allow_private_km)]
                fn my_confidential_query() -> () {}
            }
        );

        expect_module_impl(
            input,
            USES.with(|uses| {
                syn::parse_quote!(
                    const _: () = {
                        #uses
                        #[automatically_derived]
                        impl<C: Cfg> sdk::module::MethodHandler for MyModule<C> {
                            fn dispatch_query<C: Context>(
                                ctx: &C,
                                method: &str,
                                args: cbor::Value,
                            ) -> DispatchResult<cbor::Value, Result<cbor::Value, sdk::error::RuntimeError>>
                            {
                                match method {
                                    RPC_NAME_OF_MY_QUERY => module::dispatch_query(ctx, args, Self::my_query),
                                    "module.OtherQuery" => module::dispatch_query(ctx, args, Self::my_other_query),
                                    "module.ConfidentialQuery" => module::dispatch_query(ctx, args, Self::my_confidential_query),
                                    q if q == format!("{}.Parameters", Self::NAME) => {
                                        module::dispatch_query(ctx, args, Self::query_parameters)
                                    }
                                    _ => DispatchResult::Unhandled(args),
                                }
                            }
                            fn supported_methods() -> Vec<core_types::MethodHandlerInfo> {
                                vec![
                                    core_types::MethodHandlerInfo {
                                        kind: core_types::MethodHandlerKind::Query,
                                        name: RPC_NAME_OF_MY_QUERY.to_string(),
                                    },
                                    core_types::MethodHandlerInfo {
                                        kind: core_types::MethodHandlerKind::Query,
                                        name: "module.OtherQuery".to_string(),
                                    },
                                    core_types::MethodHandlerInfo {
                                        kind: core_types::MethodHandlerKind::Query,
                                        name: "module.ConfidentialQuery".to_string(),
                                    },
                                ]
                            }
                            fn is_expensive_query(method: &str) -> bool {
                                ["module.OtherQuery", "module.ConfidentialQuery"].contains(&method)
                            }
                            fn is_allowed_private_km_query(method: &str) -> bool {
                                ["module.ConfidentialQuery"].contains(&method)
                            }
                        }
                        #[automatically_derived]
                        impl<C: Cfg> MyModule<C> {
                            fn query_parameters<C: Context>(
                                _ctx: &C,
                                _args: (),
                            ) -> Result<<Self as module::Module>::Parameters, <Self as module::Module>::Error>
                            {
                                Ok(Self::params())
                            }
                            #[handler(query = RPC_NAME_OF_MY_QUERY)]
                            fn my_query() -> () {}
                            #[handler(query = "module.OtherQuery", expensive)]
                            fn my_other_query() -> () {}
                            #[handler(query = "module.ConfidentialQuery", expensive, allow_private_km)]
                            fn my_confidential_query() -> () {}
                        }
                    };
                )
            }),
        );
    }

    #[test]
    fn generate_method_handler_impl_method_calls() {
        let input = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(query = "my_module.MyMC")]
                fn my_method_call() -> () {}
            }
        );

        expect_module_impl(
            input,
            USES.with(|uses| {
                syn::parse_quote!(
                    const _: () = {
                        #uses
                        #[automatically_derived]
                        impl<C: Cfg> sdk::module::MethodHandler for MyModule<C> {
                            fn dispatch_query<C: Context>(
                                ctx: &C,
                                method: &str,
                                args: cbor::Value,
                            ) -> DispatchResult<cbor::Value, Result<cbor::Value, sdk::error::RuntimeError>>
                            {
                                match method {
                                    "my_module.MyMC" => module::dispatch_query(ctx, args, Self::my_method_call),
                                    q if q == format!("{}.Parameters", Self::NAME) => {
                                        module::dispatch_query(ctx, args, Self::query_parameters)
                                    }
                                    _ => DispatchResult::Unhandled(args),
                                }
                            }
                            fn supported_methods() -> Vec<core_types::MethodHandlerInfo> {
                                vec![core_types::MethodHandlerInfo {
                                    kind: core_types::MethodHandlerKind::Query,
                                    name: "my_module.MyMC".to_string(),
                                }]
                            }
                        }
                        #[automatically_derived]
                        impl<C: Cfg> MyModule<C> {
                            fn query_parameters<C: Context>(_ctx: &C, _args: ()) -> Result<<Self as module::Module>::Parameters, <Self as module::Module>::Error> {
                                Ok(Self::params())
                            }
                            #[handler(query = "my_module.MyMC")]
                            fn my_method_call() -> () {}
                        }
                    };
                )
            }),
        );
    }

    #[test]
    fn generate_module_impl() {
        let input = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                const NAME: &'static str = MODULE_NAME;
                const VERSION: u32 = 2;
                type Error = Error;
                type Event = ();
                type Parameters = Parameters;
                type Genesis = Genesis;

                #[migration(init)]
                fn init(genesis: Genesis) {
                    Self::set_params(genesis.parameters);
                }

                #[migration(from = 2)]
                fn migrate_v2_to_v3() {}

                #[migration(from = 1)]
                fn migrate_v1_to_v2() {}

                #[handler(query = "my_module.MyMC")]
                fn my_method_call() -> () {}
            }
        );

        expect_module_impl(
            input,
            USES.with(|uses| {
                syn::parse_quote!(
                    const _: () = {
                        #uses
                        #[automatically_derived]
                        impl<C: Cfg> sdk::module::Module for MyModule<C> {
                            const NAME: &'static str = MODULE_NAME;
                            const VERSION: u32 = 2;
                            type Error = Error;
                            type Event = ();
                            type Parameters = Parameters;
                        }
                        #[automatically_derived]
                        impl<C: Cfg> sdk::module::MigrationHandler for MyModule<C> {
                            type Genesis = Genesis;
                            fn init_or_migrate<C: Context>(
                                _ctx: &C,
                                meta: &mut sdk::modules::core::types::Metadata,
                                genesis: Self::Genesis,
                            ) -> bool {
                                let mut version = meta.versions.get(Self::NAME).copied().unwrap_or_default();
                                if version == Self::VERSION {
                                    return false;
                                }
                                if version == 0u32 {
                                    Self::init(genesis);
                                    version = Self::VERSION;
                                }
                                if version == 1u32 && version < Self::VERSION {
                                    Self::migrate_v1_to_v2();
                                    version += 1;
                                }
                                if version == 2u32 && version < Self::VERSION {
                                    Self::migrate_v2_to_v3();
                                    version += 1;
                                }
                                if version != Self::VERSION {
                                    panic!(
                                        "no migration for module state from version {version} to {}",
                                        Self::VERSION
                                    )
                                }
                                meta.versions.insert(Self::NAME.to_owned(), Self::VERSION);
                                return true;
                            }
                        }
                        #[automatically_derived]
                        impl<C: Cfg> MyModule<C> {
                            #[migration(init)]
                            fn init(genesis: Genesis) {
                                Self::set_params(genesis.parameters);
                            }
                            #[migration(from = 1)]
                            fn migrate_v1_to_v2() {}
                            #[migration(from = 2)]
                            fn migrate_v2_to_v3() {}
                        }
                        #[automatically_derived]
                        impl<C: Cfg> sdk::module::MethodHandler for MyModule<C> {
                            fn dispatch_query<C: Context>(
                                ctx: &C,
                                method: &str,
                                args: cbor::Value,
                            ) -> DispatchResult<cbor::Value, Result<cbor::Value, sdk::error::RuntimeError>>
                            {
                                match method {
                                    "my_module.MyMC" => module::dispatch_query(ctx, args, Self::my_method_call),
                                    q if q == format!("{}.Parameters", Self::NAME) => {
                                        module::dispatch_query(ctx, args, Self::query_parameters)
                                    }
                                    _ => DispatchResult::Unhandled(args),
                                }
                            }
                            fn supported_methods() -> Vec<core_types::MethodHandlerInfo> {
                                vec![core_types::MethodHandlerInfo {
                                    kind: core_types::MethodHandlerKind::Query,
                                    name: "my_module.MyMC".to_string(),
                                }]
                            }
                        }
                        #[automatically_derived]
                        impl<C: Cfg> MyModule<C> {
                            fn query_parameters<C: Context>(_ctx: &C, _args: ()) -> Result<<Self as module::Module>::Parameters, <Self as module::Module>::Error> {
                                Ok(Self::params())
                            }
                            #[handler(query = "my_module.MyMC")]
                            fn my_method_call() -> () {}
                        }
                    };
                )
            }),
        );
    }

    #[test]
    #[should_panic(expected = "invalid handler kind")]
    fn generate_method_handler_malformed_bad_kind() {
        let input: syn::ItemImpl = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(unsupported_key = "some_value")]
                fn my_method_call() -> () {}
            }
        );
        super::derive_module(input);
    }

    #[test]
    #[should_panic(expected = "only allowed on `query` handlers")]
    fn generate_method_handler_malformed_expensive_nonquery() {
        let input: syn::ItemImpl = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(call = "foo", expensive)]
                fn my_method_call() -> () {}
            }
        );
        super::derive_module(input);
    }

    #[test]
    #[should_panic(expected = "only allowed on `query` handlers")]
    fn generate_method_handler_malformed_allow_private_km_nonquery() {
        let input: syn::ItemImpl = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(call = "foo", allow_private_km)]
                fn my_method_call() -> () {}
            }
        );
        super::derive_module(input);
    }

    #[test]
    #[should_panic(expected = "only allowed on `call` handlers")]
    fn generate_method_handler_malformed_internal_noncall() {
        let input: syn::ItemImpl = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(query = "foo", internal)]
                fn my_method_call() -> () {}
            }
        );
        super::derive_module(input);
    }

    #[test]
    #[should_panic]
    fn generate_method_handler_malformed_multiple_metas() {
        let input: syn::ItemImpl = syn::parse_quote!(
            impl<C: Cfg> MyModule<C> {
                #[handler(call = "foo", query = "bar")]
                fn my_method_call() -> () {}
            }
        );
        super::derive_module(input);
    }
}
